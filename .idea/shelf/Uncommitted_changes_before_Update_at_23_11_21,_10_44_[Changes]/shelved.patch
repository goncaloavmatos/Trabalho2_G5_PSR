Index: ar_paint.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/python3\nimport argparse\nimport json\nimport cv2\nimport numpy as np\nfrom colorama import Fore, Style, Back\nimport math\nimport time\n\n# ========================================================\n# ........... Function: DISTANCE BETWEEN POINTS ..........\n# ========================================================\n\n# To help with Funcionalidade Avan√ßada 1\n\n\ndef calculate_distance(point1, point2):\n    x1, y1 = point1[0], point1[1]\n    x2, y2 = point2[0], point2[1]\n    dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return dist\n\n# ========================================================\n# ...... Function: ISOLATE LARGEST OBJECT IN A MASK ......\n# ========================================================\n\n\ndef remove_small_objects(mask):\n    # find all your connected components (white blobs in your image)\n    nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)\n    # connectedComponentswithStats yields every seperated component with information on each of them, such as size\n    # the following part is just taking out the background which is also considered a component, but most of the time\n    # we don't want that.\n    sizes = stats[1:, -1]  # extracting size from cv2.connectedComponentsWithStats\n    nb_components = nb_components - 1\n\n    # your answer image\n    mask_largest = mask\n    # for every component in the image, you keep it if it's size is equal to the largest in sizes\n    for i in range(0, nb_components):\n        if sizes[i] != max(sizes) or sizes[i] < 200:  # I added the second condition because when no large object is\n            # being detected, sometimes there are little objects that can be considered the largest ones,\n            # even if they are very small. To prevent that,the mask with the largest objects will only show objects\n            # with size bigger than 200\n            mask_largest[output == i + 1] = 0\n\n    return mask_largest\n\n# ========================================================\n# ...Function: GET LARGEST OBJECT'S CENTROID COORDINATES...\n# ========================================================\n\n\ndef get_centroid_largest(mask_largest):\n    # find all your connected components (white blobs in your image)\n    nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(mask_largest, connectivity=8)\n    # connectedComponentswithStats yields every seperated component with information on each of them, such as size\n    # the following part is just taking out the background which is also considered a component, but most of the time\n    # we don't want that.\n    # extracting size from cv2.connectedComponentsWithStats\n\n    if len(centroids) == 1:  # If no object is detected, put marker on the origin\n        centroid = (0, 0)\n        reality = False\n    else:\n        centroid = centroids[1]  # Save the largest object's centroid as a tuple\n        reality = True\n    centroid = (int(round(centroid[0])), int(round(centroid[1])))\n\n    return centroid, reality   # reality is just for debugging\n\n# ========================================================\n# .................. Function: PAINTING...................\n# ========================================================\n# Receives inputs and draws\n\ndef draw_on_whiteboard(img, marker_coord, val, painting_true, brush_size):\n    global previous_point # The last point before the marker\n    dist = calculate_distance(previous_point, marker_coord)\n\n    # If we are painting and the distance between the 2 points isn't too big\n    # And val is True (for debugging)\n\n    # ............. Shake prevention ..........................\n    # Only paints if the distance between points is small\n    if usp:\n        if painting_true and dist < 35 and val:\n\n            # paints circle where the centroid is detected\n            # divide brush size by to permit a radius of 1\n            img = cv2.circle(img, marker_coord, int(brush_size/2), colour, -1)\n\n            img = cv2.line(img, previous_point, marker_coord, colour, brush_size)  # unites close circles with line\n\n            previous_point = marker_coord  # saves the current point to be the previous point in the next iteration\n\n        else:\n            # doesn't paint but saves the current point to be the previous point in the next iteration\n            previous_point = marker_coord\n\n    # ............. Without shake prevention ..........................\n    # Paints with no regards of the distance between points\n    else:\n\n        if painting_true and val:\n\n            # paints circle where the centroid is detected\n            # divide brush size by to permit a radius of 1\n            img = cv2.circle(img, marker_coord, int(brush_size / 2), colour, -1)\n\n            img = cv2.line(img, previous_point, marker_coord, colour, brush_size)  # unites close circles with line\n\n            previous_point = marker_coord  # saves the current point to be the previous point in the next iteration\n\n        else:\n            # doesn't paint but saves the current point to be the previous point in the next iteration\n            previous_point = marker_coord\n\n    return img\n\n# ========================================================\n# .......... Function: CURRENT DATE STRING................\n# ========================================================\n# To save image EX: drawing_Tue_Sep_15_10:36:39_2020.png\n\ndef current_date():\n    named_tuple = time.localtime()  # get struct_time\n    time_string = time.strftime(\"%a_%b_%d_%H:%M:%S_%Y\", named_tuple)\n\n    return time_string\n\n# ========================================================\n# .......... Advanced function 4................\n# ========================================================\n\ndef numbered_paint():\n    #For advanced function 4\n    # img_contour = cv2.drawContours(img_nump, contours_nump_b, -1,(0,0,0), 3)\n    dim = (frame.shape[1], frame.shape[0])\n    img_nump_path = './teste.png'\n    img_nump = cv2.resize(cv2.imread(img_nump_path, cv2.IMREAD_COLOR),dim)\n    img_nump_b, img_nump_g, img_nump_r = cv2.split(img_nump)\n    _,img_nump_b_tresh = cv2.threshold(img_nump_b,0,255,0)\n    _,img_nump_g_tresh = cv2.threshold(img_nump_g,0,255,0)\n    _,img_nump_r_tresh = cv2.threshold(img_nump_r,0,255,0)\n    #Find contours for blue\n    contours_nump_b, hierarchy = cv2.findContours(img_nump_b_tresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    for c in contours_nump_b:\n        # calculate moments for each contour\n        M = cv2.moments(c)\n        # calculate x,y coordinate of center\n        cX = int(M[\"m10\"] / M[\"m00\"])\n        cY = int(M[\"m01\"] / M[\"m00\"])\n        # add number 1 in the center position of each contour\n        cv2.putText(whiteboard, \"1\", (cX, cY), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)\n    contours_nump_g, hierarchy = cv2.findContours(img_nump_g_tresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    for c in contours_nump_g:\n        # calculate moments for each contour\n        M = cv2.moments(c)\n        # calculate x,y coordinate of center\n        cX = int(M[\"m10\"] / M[\"m00\"])\n        cY = int(M[\"m01\"] / M[\"m00\"])\n        # add number 2 in the center position of each contour\n        cv2.putText(whiteboard, \"2\", (cX, cY), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)\n    contours_nump_r, hierarchy = cv2.findContours(img_nump_r_tresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n    for c in contours_nump_r:\n        # calculate moments for each contour\n        M = cv2.moments(c)\n        # calculate x,y coordinate of center\n        cX = int(M[\"m10\"] / M[\"m00\"])\n        cY = int(M[\"m01\"] / M[\"m00\"])\n        # add number 3 in the center position of each contour\n        cv2.putText(whiteboard, \"3\", (cX, cY), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)\n    global contours_2\n    contours_2=np.append(np.append(contours_nump_b,contours_nump_g),contours_nump_r)\n    pass\n\n\n\n\n# =================================================================================================\n# ............................................. MAIN FUNCTION .....................................\n# =================================================================================================\n\n\ndef main():\n\n    # ========================================================\n    # .................INITIALIZATION ........................\n    # ========================================================\n\n    global colour\n    global previous_point\n    # ..............Specify file directory....................\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-j', '--json', type=str, required=True, help='Full path to json file.')\n    parser.add_argument('-usp', '--use_shake_prevention', action='store_true', help='Prevents brush from drifting with big variations of the centroid.')\n    parser.add_argument('-nump', '--numbered_paint', action='store_true', help='Enables the numbered paint mode')\n    args = vars(parser.parse_args())\n    color_segment = args['json']\n\n    global usp\n    usp = args['use_shake_prevention']\n    global nump\n    nump = args['numbered_paint']\n\n\n    # ................ Presentation .........................\n\n    print(Fore.LIGHTBLUE_EX + Style.BRIGHT + '\\n            AUGMENTED REALITY PAINT' + Style.RESET_ALL)\n    print('___________________________________________________')\n\n    # .............. Get limits.json .........................\n\n    with open(color_segment, \"r\") as f:  # opens and reads the json file\n        ranges = json.load(f)  # saves the dictionary as ranges\n\n    #  Print the imported dictionary\n    print('\\nUse an object within the color limits you segmented as a marker.\\nYour imported limits are:\\n')\n\n    print(Fore.RED + Style.BRIGHT + 'R: ' + Style.RESET_ALL)\n    print(ranges['limits']['r'])\n\n    print(Fore.GREEN + Style.BRIGHT + 'G: ' + Style.RESET_ALL)\n    print(ranges['limits']['g'])\n\n    print(Fore.BLUE + Style.BRIGHT + 'B: ' + Style.RESET_ALL)\n    print(ranges['limits']['b'])\n    print('\\n')\n\n    # ................ Instructions ............................\n    print(Style.BRIGHT + '\\nINSTRUCTIONS:\\n' + Style.RESET_ALL)\n    print('\"p\" -> Start/stop painting\\n'\n          '\"q\" -> Quit\\n\\n'\n          'Colours\\n'\n          '\"r\" -> Change color to red\\n'\n          '\"g\" -> Change color to green\\n'\n          '\"b\" -> Change color to blue (Default)\\n'\n          '\"spacebar\" -> Eraser\\n\\n'\n          'Edit brush size\\n'\n          '\"+\" -> make bigger\\n'\n          '\"-\" -> make smaller')\n\n    print('\\n\\n\\n Press \"p\" to start painting. Press it again to stop.\\n\\n')\n\n    # Extracting minimums and maximums from ranges and saving as separate arrays\n    mins = np.array([ranges['limits']['b']['min'], ranges['limits']['g']['min'], ranges['limits']['r']['min']])\n    maxs = np.array([ranges['limits']['b']['max'], ranges['limits']['g']['max'], ranges['limits']['r']['max']])\n\n    # ========================================================\n    # .................PROCESSING IMAGE ......................\n    # ========================================================\n    cam = cv2.VideoCapture(0)\n    global frame\n    ret, frame = cam.read()  # get an image from the camera\n\n    if nump:\n        global whiteboard\n        whiteboard = np.zeros(frame.shape, dtype=np.uint8)\n        whiteboard.fill(255)\n        numbered_paint()\n        cv2.drawContours(whiteboard, contours_2, -1,(0,0,0), 3)\n    else:\n        # .............. Creating whiteboard with same size as shape ................\n        whiteboard = np.zeros(frame.shape, dtype=np.uint8)  # Set whiteboard size as the size of the captured image\n        whiteboard.fill(255)  # make every pixel white\n\n\n    # ..................... Starting values ...................................\n    # Specifying that at the start the user is not painting\n    painting = False\n    brush_size = 5\n    previous_point = (0, 0)\n    colour = (255, 0, 0) # To start with blue by default\n\n    while True:\n\n        # ........... initializing images and windows ..............................\n\n        ret, frame = cam.read()  # get an image from the camera\n        frame = cv2.flip(frame, 1)  # To make the image work like a mirror\n\n        cv2.namedWindow('Capture', cv2.WINDOW_AUTOSIZE)\n        cv2.moveWindow('Capture', 40, 30)\n        cv2.namedWindow('Whiteboard', cv2.WINDOW_AUTOSIZE)\n        cv2.moveWindow('Whiteboard', 720, 30)\n        cv2.namedWindow('Mask', cv2.WINDOW_AUTOSIZE)\n        cv2.moveWindow('Mask', 40, 600)\n        cv2.namedWindow('Largest', cv2.WINDOW_AUTOSIZE)\n        cv2.moveWindow('Largest', 720, 600)\n\n        # ............Applying segmentation limits to create a mask ......................\n\n        segmented_mask = cv2.inRange(frame, mins, maxs)\n        cv2.imshow('Mask', segmented_mask)\n\n        # ......................... Isolating Largest object ............................\n\n        mask_largest = remove_small_objects(segmented_mask)\n        cv2.imshow('Largest', mask_largest)\n\n        # add a greenish shine on the original image where the object that paints is\n        cv2.add(frame, (-10, 50, -10, 0), dst=frame, mask=mask_largest)\n\n        # .......... Setting up the point that will draw in the whiteboard ...............\n\n        # Getting the largest object's centroid coordinates\n        centroid, val = get_centroid_largest(mask_largest)\n\n        pressed = cv2.waitKey(50)\n\n        # To terminate\n        if pressed & 0xFF == ord('q'):\n            print('\\n\\nYou pressed \"q\" to quit, the program terminated.\\n\\n')\n            break\n\n        # ...................... Change colours .........................\n        if pressed & 0xFF == ord('r'):\n            colour = (0, 0, 255)\n            print('\\nCurrent colour: ' + Fore.RED + 'RED' + Style.RESET_ALL)\n\n        if pressed & 0xFF == ord('g'):\n            colour = (0, 255, 0)\n            print('\\nCurrent colour: ' + Fore.GREEN + 'GREEN' + Style.RESET_ALL)\n\n        if pressed & 0xFF == ord('b'):\n            colour = (255, 0, 0)\n            print('\\nCurrent colour: ' + Fore.BLUE + 'BLUE' + Style.RESET_ALL)\n\n        if pressed & 0xFF == ord(' '):\n            colour = (255, 255, 255)\n            print('\\nYou selected the ' + Fore.LIGHTMAGENTA_EX + 'ERASER' + Style.RESET_ALL)\n\n        if centroid != (0, 0):\n            # Showing marker in the original image\n            #frame = cv2.circle(frame, centroid, 5, colour, -1)\n            frame = cv2.putText(frame, 'x', (centroid[0]-10, centroid[1]+8), cv2.FONT_HERSHEY_PLAIN, 2, colour, 2)\n        # ..................................................................\n\n        # To clear the board\n        if pressed & 0xFF == ord('c'):\n            if nump:\n                whiteboard = np.zeros(frame.shape, dtype=np.uint8)\n                whiteboard.fill(100)\n                numbered_paint()\n            else:\n                whiteboard = np.zeros(frame.shape, dtype=np.uint8)\n                whiteboard.fill(255)  # or img[:] = 255\n            print('\\nCLEARED THE WHITEBOARD')\n\n        # To start and stop painting\n        if pressed & 0xFF == ord('p'):\n            previous_point = centroid\n            if painting is False:\n                painting = True\n                print('\\nPAINTING...\\n')\n            else:\n                painting = False\n                print('\\nNOT PAINTING.\\n')\n\n        # ....................... Changing brush size ......................\n\n        if pressed & 0xFF == ord('+'):\n            if brush_size == 55:  # To prevent brush size from getting above the maximum of 55\n                brush_size = 55\n                print(Fore.YELLOW + Style.BRIGHT + Back.RED + '\\n'+' Brush size is already at the MAXIMUM' + Style.RESET_ALL)\n\n            else:\n                brush_size += 2\n\n        if pressed & 0xFF == ord('-'):\n            if brush_size == 1:  # To prevent brush size from getting below the minimum of 1\n                brush_size = 1\n                print(Fore.RED + Style.BRIGHT + Back.YELLOW + '\\n'+' Brush size is already at the minimum' + Style.RESET_ALL)\n            else:\n                brush_size -= 2\n\n        # ................Calling the function that paints the whiteboard ................\n        whiteboard = draw_on_whiteboard(whiteboard, centroid, val, painting, brush_size)\n\n        # Showing images\n        cv2.imshow('Capture', frame)\n        cv2.imshow('Whiteboard', whiteboard)\n\n\n        # To save image EX: drawing_Tue_Sep_15_10:36:39_2020.png\n        if pressed & 0xFF == ord('w'):\n\n            save_string = \"drawing_\" + current_date() + \".png\"\n            cv2.imwrite(save_string, whiteboard)\n\n            print('\\nSaved image as: ' + Style.BRIGHT + Fore.LIGHTBLUE_EX + save_string + Style.RESET_ALL)\n\n    cam.release()\n    cv2.destroyAllWindows()\n\n\nif __name__ == '__main__':\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ar_paint.py b/ar_paint.py
--- a/ar_paint.py	(revision 5b7e3117a05872575524d569763b0ea4ff6b4d8b)
+++ b/ar_paint.py	(date 1637632221330)
@@ -274,6 +274,11 @@
     previous_point = (0, 0)
     colour = (255, 0, 0) # To start with blue by default
 
+    # p1 = (0,0)
+    # p2 = False
+    # p3 = False
+
+
     while True:
 
         # ........... initializing images and windows ..............................
@@ -338,6 +343,27 @@
             frame = cv2.putText(frame, 'x', (centroid[0]-10, centroid[1]+8), cv2.FONT_HERSHEY_PLAIN, 2, colour, 2)
         # ..................................................................
 
+        if pressed & 0xFF == ord('k'):# and p1 == (0,0) and p3 is False:
+            p1 = centroid
+            if pressed & 0xFF == ord('k'):# and p1 == (0, 0) and p3 is False:
+                p2 = centroid
+                # p3 = True
+                # p2 = True
+
+        if 0xFF != ord('k'): #and p2 is True and p3 is True:
+            # p1 = None
+            # p3 = False
+            # p2 = previous_point
+            cv2.rectangle(whiteboard, p1, p2, (255,0,0), 2)
+
+
+
+
+
+
+
+
+
         # To clear the board
         if pressed & 0xFF == ord('c'):
             if nump:
Index: limits.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"limits\": {\"b\": {\"min\": 0, \"max\": 142}, \"g\": {\"min\": 0, \"max\": 67}, \"r\": {\"min\": 113, \"max\": 255}}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/limits.json b/limits.json
--- a/limits.json	(revision 5b7e3117a05872575524d569763b0ea4ff6b4d8b)
+++ b/limits.json	(date 1637629232552)
@@ -1,1 +1,1 @@
-{"limits": {"b": {"min": 0, "max": 142}, "g": {"min": 0, "max": 67}, "r": {"min": 113, "max": 255}}}
\ No newline at end of file
+{"limits": {"b": {"min": 27, "max": 73}, "g": {"min": 16, "max": 73}, "r": {"min": 136, "max": 255}}}
\ No newline at end of file
